name: NPEC pipeline

on:
  # Runs on pushes targeting the default branch
  push:
    branches: [ "main" ]

  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:

# Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages
permissions:
  contents: write
  pages: write
  id-token: write

# Allow only one concurrent deployment, skipping runs queued between the run in-progress and latest queued.
# However, do NOT cancel in-progress runs as we want to allow these production deployments to complete.
concurrency:
  group: "pages"
  cancel-in-progress: false

env:
  MIN_COVERAGE_REQUIRED: 70

jobs:
  DockerSetup:
    runs-on: ubuntu-latest
    steps:
      #----------------------------------------------
      #       check-out repo and set-up python
      #----------------------------------------------
      - name: Check out repository
        uses: actions/checkout@v4
      - name: Set up python
        id: setup-python
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'
      #----------------------------------------------
      #  -----  install & configure poetry  -----
      #----------------------------------------------
      - name: Install Poetry
        uses: snok/install-poetry@v1
        with:
          virtualenvs-create: true
          virtualenvs-in-project: true
          installer-parallel: true

      #----------------------------------------------
      #       load cached venv if cache exists
      #----------------------------------------------
      - name: Load cached venv
        id: cached-poetry-dependencies
        uses: actions/cache@v3
        with:
          path: .venv
          key: venv-${{ runner.os }}-${{ steps.setup-python.outputs.python-version }}-${{ hashFiles('**/poetry.lock') }}
      #----------------------------------------------
      # install dependencies if cache does not exist
      #----------------------------------------------
      - name: Install dependencies
        if: steps.cached-poetry-dependencies.outputs.cache-hit != 'true'
        run: poetry install --no-interaction --no-root
      #----------------------------------------------
      # install your root project, if required
      #----------------------------------------------
      - name: Install project
        run: poetry install --no-interaction
      #----------------------------------------------
      #              run test suite
      #----------------------------------------------
      - name: Build the Docker image
        run: |
          poetry export --without-hashes --format=requirements.txt > requirements.txt
          docker-compose build
      - name: Export Docker Image
        run: |
          docker save --output temp_image.tar super_plant_phenotyper3000:latest
          ls
      - name: Upload Docker Image
        uses: actions/upload-artifact@v4
        with:
          name: docker_img
          path: temp_image.tar

  UnitTest:
    needs: DockerSetup
    runs-on: ubuntu-latest
    steps:
      - name: Download Docker Image
        uses: actions/download-artifact@v4
        with:
          name: docker_img
      - name: Load image
        run: |
          ls
          docker load --input temp_image.tar
          docker image ls -a
      - name: Run Unit Tests
        run: |
          docker run --name super_plant_phenotyper3000 -d super_plant_phenotyper3000:latest
          docker exec -i super_plant_phenotyper3000 bash
          python coverage run -m pytest unittest discover
      - name: Github Action to retrieve coverage percentage
        id: total-coverage
        run: |
          python coverage json -q -o /dev/stdout | python -c 'import sys, json; perc_cov = json.load(sys.stdin)["totals"]["percent_covered"]; is_covered = perc_cov >= '$MIN_COVERAGE_REQUIRED'; print("Coverage is: ", perc_cov); sys.exit(not is_covered)'

  GenerateDocs:
    needs: DockerSetup
    runs-on: ubuntu-latest
    steps:
      - name: Download Docker Image
        uses: actions/download-artifact@v4
        with:
          name: docker_img
      - name: Load image
        run: |
          ls
          docker load --input temp_image.tar
          docker image ls -a
      - name: Refresh docs
        if: ${{ hashFiles('docs/') != '' }}
        run:
          docker run --name super_plant_phenotyper3000 -d super_plant_phenotyper3000:latest
          docker exec -i super_plant_phenotyper3000 bash
          rm -r docs
      - name: Generate docs
        run: |
          docker run --name super_plant_phenotyper3000 -d super_plant_phenotyper3000:latest
          docker exec -i super_plant_phenotyper3000 bash
          python sphinx-quickstart docs --quiet -p NPEC -a BUas -v 1.0 -t config/
          python sphinx-apidoc -o docs src/
          cd docs
          pip install sphinx-rtd-theme
          python make html
  #      - name: update changes
  #        run: |
  #          git config user.name "Borislav Nachev"
  #          git config user.email "220472@buas.nl"
  #          git add .
  #          git add htmlcov/index.html -f
  #          git commit -m "auto commit"
  #          git push

  DeployHtml:
    needs: GenerateDocs
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Setup Pages
        uses: actions/configure-pages@v5
      - name: Upload artifact
        uses: actions/upload-pages-artifact@v3
        with:
          # Upload entire repository
          path: '.'
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4